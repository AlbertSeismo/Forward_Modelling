"""
Forward modelling for point masses
"""
import numpy as np
from numba import jit

from ..constants import GRAVITATIONAL_CONST
from .utils import (
    distance_cartesian,
    _distance_sq_cartesian,
    distance_spherical,
    _distance_sq_spherical,
)


def point_mass_gravity(
    coordinates, points, masses, field, coordinate_system="cartesian", dtype="float64"
):
    """
    Compute gravitational fields of a point mass on spherical coordinates.

    Parameters
    ----------
    coordinates : list or array
        List or array containing the coordinates of computation points in the following
        order: `easting`, `northing` and `vertical` (if coordinates given in Cartesian
        coordiantes), or `longitude`, `latitude` and `radius` (if given on a spherical
        geocentric coordinate system).
        All `easting`, `northing` and `vertical` should be in meters.
        Both `longitude` and `latitude` should be in degrees and `radius` in meters.
    points : list or array
        List or array containing the coordinates of the point masses in the following
        order: `easting`, `northing` and `vertical` (if coordinates given in Cartesian
        coordiantes), or `longitude`, `latitude` and `radius` (if given on a spherical
        geocentric coordinate system).
        All `easting`, `northing` and `vertical` should be in meters.
        Both `longitude` and `latitude` should be in degrees and `radius` in meters.
    masses : list or array
        List or array containing the mass of each point mass in kg.
    field : str
        Gravitational field that wants to be computed.
        The available fields in Cartesian coordinates are:

        - Gravitational potential: ``potential``
        - Vertical acceleration: ``g_z``

        The available fields in spherical geocentric coordinates are:

        - Gravitational potential: ``potential``
        - Radial acceleration: ``g_r``

    coordinate_system : str (optional)
        Coordinate system of the coordinates of the computation points and the point
        masses. Available coordinates systems: ``cartesian``, ``spherical``.
        Default ``cartesian``.
    dtype : data-type (optional)
        Data type assigned to resulting gravitational field, and coordinates of point
        masses and computation points. Default to ``np.float64``.


    Returns
    -------
    result : array
        Gravitational field generated by the `point_mass` on the computation points
        defined in `coordinates`.
        The potential is given in SI units, the accelerations in mGal and the Marussi
        tensor components in Eotvos.
    """
    # Organize dispatchers and kernel functions inside dictionaries
    dispatchers = {
        "cartesian": jit_point_mass_cartesian,
        "spherical": jit_point_mass_spherical,
    }
    kernels = {
        "cartesian": {"potential": kernel_potential_cartesian, "g_z": kernel_g_z},
        "spherical": {"potential": kernel_potential_spherical, "g_r": kernel_g_r},
    }
    # Sanity checks for coordinate_system and field
    if coordinate_system not in ("cartesian", "spherical"):
        raise ValueError(
            "Coordinate system {} not recognized".format(coordinate_system)
        )
    if field not in kernels[coordinate_system]:
        raise ValueError("Gravity field {} not recognized".format(field))
    # Figure out the shape and size of the output array
    cast = np.broadcast(*coordinates[:3])
    result = np.zeros(cast.size, dtype=dtype)
    # Prepare arrays to be passed to the jitted functions
    coordinates = (np.atleast_1d(i).ravel().astype(dtype) for i in coordinates[:3])
    points = (np.atleast_1d(i).ravel().astype(dtype) for i in points[:3])
    masses = np.atleast_1d(masses).astype(dtype).ravel()
    # Compute gravitational field
    dispatchers[coordinate_system](
        *coordinates, *points, masses, result, kernels[coordinate_system][field]
    )
    result *= GRAVITATIONAL_CONST
    # Convert to more convenient units
    if field in ("g_r", "g_z"):
        result *= 1e5  # SI to mGal
    return result.reshape(cast.shape)


@jit(nopython=True)
def jit_point_mass_cartesian(
    easting, northing, vertical, easting_p, northing_p, vertical_p, masses, out, kernel
):  # pylint: disable=invalid-name
    """
    Compute gravity field of point masses on computation points in Cartesian coordinates

    Parameters
    ----------
    easting, northing, vertical : 1d-arrays
        Coordinates of computation points in Cartesian coordinate system.
    easting_p, northing_p, vertical_p : 1d-arrays
        Coordinates of point masses in Cartesian coordinate system.
    masses : 1d-array
        Mass of each point mass in SI units.
    out : 1d-array
        Array where the gravitational field on each computation point will be appended.
        It must have the same size of ``easting``, ``northing`` and ``vertical``.
    kernel : func
        Kernel function that will be used to compute the gravity field on the
        computation points.
    """
    for l in range(easting.size):
        for m in range(easting_p.size):
            out[l] += masses[m] * kernel(
                easting[l],
                northing[l],
                vertical[l],
                easting_p[m],
                northing_p[m],
                vertical_p[m],
            )


@jit(nopython=True)
def kernel_potential_cartesian(
    easting, northing, vertical, easting_p, northing_p, vertical_p
):
    """
    Kernel function for potential gravity field in Cartesian coordinates
    """
    return 1 / distance_cartesian(
        [easting, northing, vertical], [easting_p, northing_p, vertical_p]
    )


@jit(nopython=True)
def kernel_g_z(easting, northing, vertical, easting_p, northing_p, vertical_p):
    """
    Kernel function for downward component of gravity gradient in Cartesian coordinates
    """
    distance_sq = _distance_sq_cartesian(
        [easting, northing, vertical], [easting_p, northing_p, vertical_p]
    )
    return (vertical - vertical_p) / distance_sq ** (3 / 2)


@jit(nopython=True)
def jit_point_mass_spherical(
    longitude, latitude, radius, longitude_p, latitude_p, radius_p, masses, out, kernel
):  # pylint: disable=invalid-name
    """
    Compute gravity field of point masses on computation points in spherical coordiantes

    Parameters
    ----------
    longitude, latitude, radius : 1d-arrays
        Coordinates of computation points in spherical geocentric coordinate system.
    longitude_p, latitude_p, radius_p : 1d-arrays
        Coordinates of point masses in spherical geocentric coordinate system.
    masses : 1d-array
        Mass of each point mass in SI units.
    out : 1d-array
        Array where the gravitational field on each computation point will be appended.
        It must have the same size of ``longitude``, ``latitude`` and ``radius``.
    kernel : func
        Kernel function that will be used to compute the gravity field on the
        computation points.
    """
    # Compute quantities related to computation point
    longitude = np.radians(longitude)
    latitude = np.radians(latitude)
    cosphi = np.cos(latitude)
    sinphi = np.sin(latitude)
    # Compute quantities related to point masses
    longitude_p = np.radians(longitude_p)
    latitude_p = np.radians(latitude_p)
    cosphi_p = np.cos(latitude_p)
    sinphi_p = np.sin(latitude_p)
    # Compute gravity field
    for l in range(longitude.size):
        for m in range(longitude_p.size):
            out[l] += masses[m] * kernel(
                longitude[l],
                cosphi[l],
                sinphi[l],
                radius[l],
                longitude_p[m],
                cosphi_p[m],
                sinphi_p[m],
                radius_p[m],
            )


@jit(nopython=True)
def kernel_potential_spherical(
    longitude, cosphi, sinphi, radius, longitude_p, cosphi_p, sinphi_p, radius_p
):
    """
    Kernel function for potential gravity field in spherical coordinates
    """
    distance_sq, _, _ = _distance_sq_spherical(
        longitude, cosphi, sinphi, radius, longitude_p, cosphi_p, sinphi_p, radius_p
    )
    return 1 / np.sqrt(distance_sq)


@jit(nopython=True)
def kernel_g_r(
    longitude, cosphi, sinphi, radius, longitude_p, cosphi_p, sinphi_p, radius_p
):
    """
    Kernel function for radial component of gravity gradient in spherical coordinates
    """
    distance_sq, cospsi, _ = _distance_sq_spherical(
        longitude, cosphi, sinphi, radius, longitude_p, cosphi_p, sinphi_p, radius_p
    )
    delta_z = radius_p * cospsi - radius
    return delta_z / distance_sq ** (3 / 2)
